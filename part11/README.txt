Что дальше?

I. Деревья.
Бинарное дерево поиска. Для каждого узла все узлы левого поддерева содержат меньшее значения, а все узлы правого дерева - большие значения.
Поиск элемента в бинарном дереве поиска в среднем выполняется за время O(log n), а в худшем случае - за время O(n).
Поиск в отсортированном массиве выполняется за время O(log n) в худшем случае - казалось бы, отсортированный массив эффективнее.
Однако бинарное дерево поиска в среднем работает быстрее при удалении и вставке элементов.

Недостатка бинарных деревьев поиска:
- Они не поддерживают произвольный доступ;
- Время выполнения операций зависит от сбалансированности дерева (специальные бинарные деревья, способные к самобалансировке - красно-черные деревья).

В-деревья, особая разновидность бинарных деревьев, обычно используются для хранения информации в БД.
Посмотреть информацию по: в-деревья, красно-черные деревья, кучи, скошенные (splay) деревья.


II. Инвертированные индексы.
Сильно упрощенное объяснение, как работает поисковая система.
Ключами хеш-таблицы являются слова, а значения указывают, на каких страницах встречается каждое слово.
Такая структура данных, называемая инвертированным индексом, часто используется для построения поисковых систем.


III. Преобразование Фурье.
Лучшая аналогия для преобразования Фурье: есть коктейль, преобразование Фурье сообщает, из каких ингредиентов он состоит.
Например, если песню можно разложить на частоты, можно усилить тот или иной диапазон.


IV. Параллельные алгоритмы (масштабируемость и обработка больших объемов данных).
Разновидность параллельных алгоритмов: распределенные алгоритмы.
Распределенные алгоритмы хорошо работают в тех ситуациях, когда нужно выполнить большой объем работы и необходимо сократить время ее выполнения.

MapReduce - представитель семейства распределенных алгоритмов. В основе лежит идеи: функция отображения map и функция свертки reduce.
1. map - получает массив и применяет одну функцию к каждому элементу массива.
res = map(download_page, array) - имеется список URL-адресов и нужно загрузить каждую страницу и сохранить содержимое в res.
2. reduce - идея в том что весь список элементов "сокращается" до одного элемента.
[1, 2, 3, 4, 5] => 15.

Фильтр Блума (вероятностные структуры данных).
Они дают ответ, который может оказаться ложным, но с большей вероятностью является правильным:
- возможны ложно-положительные срабатывания. Фильтр скажет что сайт обрабатывался, хотя этого не было;
- ложно-отрицательные срабатывания исключены. Если фильтр утверждает, что сайт не обрабатывался, можно быть в этом уверенным.
Фильтр Блума занимает очень мало места (хеш-таблице пришлось бы хранить все URL-адреса, обрабатываемые Google, а фильтру Блума это не нужно).

Примерно также действует алгоритм HyperLogLog.
Предположим, Google хочет посчитать количество уникальных поисков, выполненных пользователями.
В таком случае придется вести журнал всех уникальных вариантов поиска. Когда пользователь что-то ищет, нужно проверить, присутствует ли условие в журнале,
и если нет, то добавить. И этот журнал получится гигантским.
HyperLogLog аппроксимирует количество уникальных элементов в множестве. Он не дает точного ответа, но выдает достаточно близкий результат.


V. Алгоритм SHA (Secure Hash Algorithm). Получает строку и возвращает хеш-код этой строки.
Алгоритм SHA - хеш-функция; эта функция генерирует хеш-код, который представляет собой короткую строку.
Хеш-функция для хеш-таблиц преобразует строку в индекс массива, тогда как SHA преобразует строку в другую строку.

Алгоритм SHA позволяет определить, совпадает ли два файла.
Алгоритм SHA также используется для сравнения строк при отсутствии информации об исходной строке (пароли).

- Локально-чувствительное хеширование (алгоритм SHA). При незначительном изменении строки, сгенерированный хеш полностью изменится.
- Локально-чувствительное хеширование (алгоритм Simhash). При незначительном изменении строки Simhash генерирует хеш-код,
который почти не отличается от исходного (для обнаружения плагиата).


VI. Обмен ключами Диффи-Хеллмана.
Решают задачу: Как зашифровать сообщение так, чтобы его мог прочитать только тот человек, которому адресовано сообщение?

Алгоритм Диффи-Хеллмана использует два ключа: открытый и закрытый. Открытый ключ известен обеим сторонам (его не нужно скрывать).
Когда другая сторона захочет отправить вам сообщение, она зашифрует его с применением открытого ключа. Зашифрованное сообщение
можно расшифровать только с закрытым ключом.
Дальше изучение криптографии.


VII. Линейное программирование.
Линейное программирование используется для максимизации некоторой характеристики при заданных ограничениях.
Все алгоритмы, работающие с графами, могут быть реализованы средствами линейного программирования.
Линейное программирование - намного более общая область, а задачи с графами составляют ее подмножество.
В линейном программировании используются симплекс-метод.











