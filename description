Грокаем алгоритмы

part1. Знакомство с алгоритмами (О-большое, бинарный поиск)
    "О-большое". Специальная нотация - описывает скорость работы алгоритма.
    Разновидности:
    1. O(log n), или логарифмическое время (бинарный поиск);
    2. O(n), или линейное время (простой поиск);
    3. O(n * log n) (эффективные алгоритмы сортировки (быстрая сортировка));
    4. O(n * n) (медленные алгоритмы сортировки (сортировка выбором));
    5. O(n!) (очень медленные алгоритмы (задача о коммивояжере)).

    Бинарный поск - на вход отсортированный список элементов. Если элемент присутствует в списке, то возвращает его позицию.


part2. Сортировка выбором
    Время выполнения алгоритма сортировки выбором O(n * n).


part3. Рекурсия
    "Циклы могут ускорить работу программы. Рекурсия может ускорить работу программиста. Выбирайте, что важнее в вашей ситуации".

    Стек вызовов. Новые элементы добавляются в начало списка (последним вставлен - первым извлечен).
    Стек принадлежит к числу структур даных LIFO: last in first out

    Когда функция вызывается из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии.
    Все значения переменных этой функции остаются в памяти, а когда выполнении вызываемой функции завершится, управление вернется
    вызывающий функции и продолжит выполнении с того места, где оно прервалось.

    Стек вызовов с рекурсией.
    Стек удобен, но сохранение всей промежуточной информации может привести к значительным затратам памяти.
    В таком случае: 1. переписать код с использованием цикла; 2. воспользоваться "хвостовой рекурсией".


part4. Быстрая сортировка
    Скорость работы алгоритма быстрой сортировки зависит от выбора опорного элемента.
    В худшем случае быстрая сортировка работает за время О(n * n). В среднем быстрая сортировка работает за время O(n log n).

    А сортировка слиянием всегда выполняется за O(n log n).

    Если быстрая сортировка в среднем выполняется за время O(n log n), а сортировка слиянием выполняется за время O(n log n) всегда,
    то почему не использовать сотировку слиянием?

    Когда используют О-большое (например, О(n)), в действительности это означает следующее:
     с * n
    c - некторый фиксированный промежуток времени для алгоритма (константа).

    Обычно константа игнорируется, потому что если два алгоритма имеют разное время "О-большое", она роли не играет.
    Однако в некоторых случаях константа может иметь значение. Один из примеров - быстрая сортировка и сортировка слиянием.
    У быстрой сортировки константа меньше, чем у сортировки слиянием, поэтому несмотря на то что оба алгоритма характеризуются
    временеи О(n * log n), быстрая сортировка работает быстрее. А на практике быстрая сортировка работает быстрее, потому что
    средний случай встречается намного чаще худшего.
    Как выглядит средний случай по сравнению с худшим? Если всегда выбирать опорным элементом случайный элемент в массиве.


part5. Хеш-таблицы
    Хэш таблицы (ассоциативные массивы (ключ и значение))
    Коллизия - двум ключам назначается один элемент массива. Простейший способ обработки коллизий - если несколько ключей
    отображаются на один элемент, в этом элементе создается связанный список.
    Но если связанный список становитс слишком длинным, работа с хэш-таблицей сильно замедляется.

    Для среднего случая время выполнения О(1), для худшего случая О(n)

    Для предотвращения коллизий необходимо:
    - низкий коэффициент заполнения. Коэффициент заполнения = количество элементов в хэш-таблице / общее количество элементов (рекомендация: 0.7);
    - хорошая хэш-функция (прочитать про алгорит SHA).


part6. Поиск в ширину
    Поиск в ширину - BFS, Breadth-First Search (алгоритм работающий с графами).

    Поиск в ширину позволяет найти кратчайшее расстояние между двумя объектами (например, программа для игры в шашки, которая вычисляет кратчайший путь к победе).

    Графы используют для моделирования связей между разными объектами, состоят из узлов и ребер. Узел может быть напрямую соеденен с несколькими другими узлами. Эти узлы называются соседями.

    Алгоритм поиска в ширину отвечает на вопросы: существует ли путь от узла А к узлу Б? как выглядит кратчайший путь из А в Б?

    Поиск в ширину распространяется от начальной точки, связи первого уровня будут проверены до связей второго уровня.
    Связи нужно проверять в порядке их добавления, сохранять очередность.

    Очередь (нельзя обращаться к произвольным элементам очереди), две операйии: постановка в очередь и извлечение из очереди.
    Очередь относится к категории структур данных FIFO: first in first out (первым вошел, первым вышел).

    Время выполнения алгоритма поиска в ширину О(количество вершин + количество ребер).


part7. Алгоритм Дейкстры
part8. Жадные алгоритмы
part9. Динамическое программирование
part10. Алгоритм k ближайших соседей
part11. Что дальше?