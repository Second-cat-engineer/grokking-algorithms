Грокаем алгоритмы

part1. Знакомство с алгоритмами (О-большое, бинарный поиск)
part2. Сортировка выбором
part3. Рекурсия
part4. Быстрая сортировка
part5. Хеш-таблицы
part6. Поиск в ширину
part7. Алгоритм Дейкстры
part8. Жадные алгоритмы
part9. Динамическое программирование
part10. Алгоритм k ближайших соседей
part11. Что дальше?


PART 1. Знакомство с алгоритмами (О-большое, бинарный поиск)
"О-большое". Специальная нотация - описывает скорость работы алгоритма.
Разновидности:
1. O(log n), или логарифмическое время (бинарный поиск);
2. O(n), или линейное время (простой поиск);
3. O(n * log n) (эффективные алгоритмы сортировки (быстрая сортировка));
4. O(n * n) (медленные алгоритмы сортировки (сортировка выбором));
5. O(n!) (очень медленные алгоритмы (задача о коммивояжере)).

Бинарный поиск: на вход отсортированный список элементов. Если элемент присутствует в списке, то возвращает его позицию.


PART 2. Сортировка выбором.
Время выполнения алгоритма сортировки выбором O(n * n).


PART 3. Рекурсия.
"Циклы могут ускорить работу программы. Рекурсия может ускорить работу программиста. Выбирайте, что важнее в вашей ситуации".

Стек вызовов. Новые элементы добавляются в начало списка (последним вставлен - первым извлечен).
Стек принадлежит к числу структур данных LIFO: last in first out

Когда функция вызывается из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии. Все значения переменных этой функции остаются в памяти, а когда выполнении вызываемой функции завершится, управление вернется вызывающий функции и продолжит выполнение с того места, где оно прервалось.

Стек вызовов с рекурсией.
Стек удобен, но сохранение всей промежуточной информации может привести к значительным затратам памяти. В таком случае: 1. переписать код с использованием цикла; 2. воспользоваться "хвостовой рекурсией".


PART 4. Быстрая сортировка.
Скорость работы алгоритма быстрой сортировки зависит от выбора опорного элемента.
В худшем случае быстрая сортировка работает за время О(n * n). В среднем быстрая сортировка работает за время O(n log n). А сортировка слиянием всегда выполняется за O(n log n).
Если быстрая сортировка в среднем выполняется за время O(n log n), а сортировка слиянием выполняется за время O(n log n) всегда, то почему не использовать сортировку слиянием?

Когда используют О-большое (например, О(n)), в действительности это означает следующее: с * n, c - некоторый фиксированный промежуток времени для алгоритма (константа).

Обычно константа игнорируется, потому что если два алгоритма имеют разное время "О-большое", она роли не играет. Однако в некоторых случаях константа может иметь значение. Один из примеров - быстрая сортировка и сортировка слиянием.
У быстрой сортировки константа меньше, чем у сортировки слиянием, поэтому несмотря на то что оба алгоритма характеризуются временем О(n * log n), быстрая сортировка работает быстрее. А на практике быстрая сортировка работает быстрее, потому что средний случай встречается намного чаще худшего.
Как выглядит средний случай по сравнению с худшим? Если всегда выбирать опорным элементом случайный элемент в массиве.


PART 5. Хеш-таблицы.
Хэш таблицы (ассоциативные массивы (ключ и значение))
Коллизия - двум ключам назначается один элемент массива. Простейший способ обработки коллизий - если несколько ключейотображаются на один элемент, в этом элементе создается связанный список.
Но если связанный список становится слишком длинным, работа с хэш-таблицей сильно замедляется.

Для среднего случая время выполнения О(1), для худшего случая О(n)

Для предотвращения коллизий необходимо:
- низкий коэффициент заполнения. Коэффициент заполнения = количество элементов в хэш-таблице / общее количество элементов (рекомендация: 0.7);
- хорошая хэш-функция (прочитать про алгоритм SHA).


PART 6. Поиск в ширину.
Поиск в ширину - BFS, Breadth-First Search (алгоритм работающий с графами).
Поиск в ширину позволяет найти кратчайшее расстояние между двумя объектами (например, программа для игры в шашки, которая вычисляет кратчайший путь к победе).

Графы используют для моделирования связей между разными объектами, состоят из узлов и ребер. Узел может быть напрямую соединен с несколькими другими узлами. Эти узлы называются соседями.

Алгоритм поиска в ширину отвечает на вопросы: существует ли путь от узла А к узлу Б? Как выглядит кратчайший путь из А в Б?

Поиск в ширину распространяется от начальной точки, связи первого уровня будут проверены до связей второго уровня. Связи нужно проверять в порядке их добавления, сохранять очередность.

Очередь (нельзя обращаться к произвольным элементам очереди), две операции: постановка в очередь и извлечение из очереди.
Очередь относится к категории структур данных FIFO: first in first out (первым вошел, первым вышел).

Время выполнения алгоритма поиска в ширину О(количество вершин + количество ребер).


PART 7. Алгоритм Дейкстры.
Алгоритм Дейкстры (только с НАПРАВЛЕННЫМИ АЦИКЛИЧЕСКИМИ графами, также не может использоваться при наличии ребер,имеющих отрицательный вес (для этого алгоритм Беллмана-Форда)).
Поиск в ширину находит путь с минимальным количеством сегментов, алгоритм Дейкстры находит самый быстрый путь.

Алгоритм Дейкстры состоит из 4-х шагов:
1. Найти узел с наименьшей стоимостью (т.е. узел, до которого можно добраться за минимальное время);
2. Обновить стоимость соседей этого узла (проверить, существует ли более дешевый путь к соседям этого узла, и если существует, обновить их стоимость);
3. Повторять, пока это не будет сделано всех узлов графа;
4. Вычислить итоговый путь.

Терминология.
Когда работаешь с Алгоритмом Дейкстры, с каждым ребром графа связывается число - вес.
Граф с весами называется взвешенным графом. Граф без весов называется невзвешенным графом.
В графах могут присутствовать циклы (можно начать с некоторого узла, перемещаться по графу, а потом снова оказаться в том же узле).
Графы бывают направленные и ненаправленные. В ненаправленном графе каждое новое ребро добавляет еще один цикл.
Алгоритм Дейкстры работает только с НАПРАВЛЕННЫМИ АЦИКЛИЧЕСКИМИ графами (DAG, Directed Acyclic Graph).

Нужно построить таблицу со стоимостями всех узлов (стоимость узла определяет затраты на его достижение).
Таблица будет обновляться по мере работы алгоритма. Для вычисления итогового пути в таблицу необходимо добавить столбец "родитель".


PART 8. Жадные алгоритмы.
На каждом шаге выбирается локально-оптимальное решение, в итоге получается глобально-оптимальное решение.
Но так не всегда работает.
Жадные алгоритмы просто реализуются, а полученные результаты обычно близки к оптимуму (приближенные алгоритмы).
Приближенные алгоритмы - когда вычисления занимают слишком много времени, применяется приближенный алгоритм.
Эффективность приближенного алгоритма оценивается по быстроте и близости полученного решения к оптимальному.
Жадный алгоритм выполняется за время О(n^2).

Множество. Это структура данных похожий на список, но каждый элемент может встречаться в множестве не более одного раза.
- Объединение множеств означает слияние элементов обоих множеств.
- Пересечение множеств - поиск элементов, входящих в оба множества.
- Разность множеств - исключение из одного множества элементов, присутствующих в другом множестве.

NP-полные задачи. Некоторые задачи имеют сложное решение - задача о коммивояжере и задача о покрытии множества. Написать
быстрый алгоритм для решения таких задач невозможно.
Не существует простого способа определить, является ли задача NP-полной. Несколько характерных признаков:
1. Алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа;
2. Формулировка "все комбинации Х";
3. Приходится вычислять все возможные варианты Х, потому что задачу невозможно разбить на меньшие подзадачи? м.б. NP-полной;
4. Если в задаче встречается некоторая последовательность (например, последовательность городов) и задача не имеет простого решения? м.б. NP-полной;
5. Если в задаче встречается некоторое множество (например, множество радиостанций) и задача не имеет простого решения? м.б. NP-полной;
6. Можно ли переформулировать задачу в условиях задачи покрытия множества или задачи о коммивояжере? В таком случае определенно NP-полная задача;


PART 9. Динамическое программирование.
Например, для решения задачи с рюкзаком. Процедура начинается с решения подзадач с постепенным переходом к решению полной задачи.
Для начала следует решить задачи для меньшего рюкзака ("подрюкзака"), а потом на этой основе попытаться решить исходную задачу.

Каждый алгоритм динамического программирования начинается с таблицы.
Значения ячеек таблицы обычно соответствуют оптимизируемой характеристике. Для задачи о рюкзаке значения представляли общую стоимость товаров.
Каждая ячейка представляет подзадачу, поэтому необходимо разбить задачу на подзадачу и определиться с осями таблицы.
В задаче о рюкзаке - строки представляют предметы, а столбцы - емкость рюкзака.

- Динамическое программирование применяется для оптимизации какой-либо характеристики при заданных ограничениях.
В задаче о рюкзаке требуется максимизировать стоимость отобранных предметов с ограничениями по емкости рюкзака.
- Динамическое программирование работает только в ситуациях, в которых задача может быть разбита на автономные подзадачи, не зависящие друг от друга.

Алгоритм Фейнмана: 1. Записать формулировку задачи; 2. Хорошенько подумать; 3. Записать решение.


PART 10. Алгоритм k ближайших соседей.
Допустим, необходимо спрогнозировать какую оценку поставит фильму какой-то пользователь. Возьмем его k ближайших соседей, оценивших фильм. Вычислить среднее значение. Такой метод прогнозирования называется регрессией.

У алгоритма k ближайших соседей есть два основных применения:
1. Классификация = распределение по категориям;
2. Регрессия = прогнозирование ответа (в числовом выражении).

При работе с алгоритмом k ближайших соседей, очень важно правильно выбрать признаки для сравнения. "Извлечением признаков"называется преобразование элемента (например, фрукта или пользователя) в список чисел, которые могут использоваться для сравнения.

Машинное обучение (сделать компьютер более разумным).
1. OCP (Optical Character Recognition) оптическое распознавание текста (из фото -> в текст). Основана на выделении линий, точек и кривых.
2. Построение спам-фильтра (использует алгоритм "наивный классификатор Байеса").
3. Прогнозы на биржевых торгах, задача, в которой трудно добиться успеха машинным обучением: точно спрогнозировать курсы акций на бирже.


PART 11. Что дальше?
I. Деревья.
Бинарное дерево поиска. Для каждого узла все узлы левого поддерева содержат меньшее значения, а все узлы правого дерева - большие значения.
Поиск элемента в бинарном дереве поиска в среднем выполняется за время O(log n), а в худшем случае - за время O(n).
Поиск в отсортированном массиве выполняется за время O(log n) в худшем случае - казалось бы, отсортированный массив эффективнее.
Однако бинарное дерево поиска в среднем работает быстрее при удалении и вставке элементов.

Недостатка бинарных деревьев поиска:
- Они не поддерживают произвольный доступ;
- Время выполнения операций зависит от сбалансированности дерева (специальные бинарные деревья, способные к самобалансировке - красно-черные деревья).

В-деревья, особая разновидность бинарных деревьев, обычно используются для хранения информации в БД.
Посмотреть информацию по: в-деревья, красно-черные деревья, кучи, скошенные (splay) деревья.

II. Инвертированные индексы.
Сильно упрощенное объяснение, как работает поисковая система.
Ключами хеш-таблицы являются слова, а значения указывают, на каких страницах встречается каждое слово.
Такая структура данных, называемая инвертированным индексом, часто используется для построения поисковых систем.

III. Преобразование Фурье.
Лучшая аналогия для преобразования Фурье: есть коктейль, преобразование Фурье сообщает, из каких ингредиентов он состоит.
Например, если песню можно разложить на частоты, можно усилить тот или иной диапазон.

IV. Параллельные алгоритмы (масштабируемость и обработка больших объемов данных).
Разновидность параллельных алгоритмов: распределенные алгоритмы.
Распределенные алгоритмы хорошо работают в тех ситуациях, когда нужно выполнить большой объем работы и необходимо сократить время ее выполнения.

MapReduce - представитель семейства распределенных алгоритмов. В основе лежит идеи: функция отображения map и функция свертки reduce.
1. map - получает массив и применяет одну функцию к каждому элементу массива.
res = map(download_page, array) - имеется список URL-адресов и нужно загрузить каждую страницу и сохранить содержимое в res.
2. reduce - идея в том что весь список элементов "сокращается" до одного элемента.
[1, 2, 3, 4, 5] => 15.

Фильтр Блума (вероятностные структуры данных).
Они дают ответ, который может оказаться ложным, но с большей вероятностью является правильным:
- возможны ложно-положительные срабатывания. Фильтр скажет что сайт обрабатывался, хотя этого не было;
- ложно-отрицательные срабатывания исключены. Если фильтр утверждает, что сайт не обрабатывался, можно быть в этом уверенным.
Фильтр Блума занимает очень мало места (хеш-таблице пришлось бы хранить все URL-адреса, обрабатываемые Google, а фильтру Блума это не нужно).

Примерно также действует алгоритм HyperLogLog.
Предположим, Google хочет посчитать количество уникальных поисков, выполненных пользователями. В таком случае придется вести журнал всех уникальных вариантов поиска. Когда пользователь что-то ищет, нужно проверить, присутствует ли условие в журнале, и если нет, то добавить. И этот журнал получится гигантским.
HyperLogLog аппроксимирует количество уникальных элементов в множестве. Он не дает точного ответа, но выдает достаточно близкий результат.

V. Алгоритм SHA (Secure Hash Algorithm). Получает строку и возвращает хеш-код этой строки.
Алгоритм SHA - хеш-функция; эта функция генерирует хеш-код, который представляет собой короткую строку.
Хеш-функция для хеш-таблиц преобразует строку в индекс массива, тогда как SHA преобразует строку в другую строку.

Алгоритм SHA позволяет определить, совпадает ли два файла.
Алгоритм SHA также используется для сравнения строк при отсутствии информации об исходной строке (пароли).

- Локально-чувствительное хеширование (алгоритм SHA). При незначительном изменении строки, сгенерированный хеш полностью изменится.
- Локально-чувствительное хеширование (алгоритм Simhash). При незначительном изменении строки Simhash генерирует хеш-код, который почти не отличается от исходного (для обнаружения плагиата).

VI. Обмен ключами Диффи-Хеллмана.
Решают задачу: Как зашифровать сообщение так, чтобы его мог прочитать только тот человек, которому адресовано сообщение?

Алгоритм Диффи-Хеллмана использует два ключа: открытый и закрытый. Открытый ключ известен обеим сторонам (его не нужно скрывать).
Когда другая сторона захочет отправить вам сообщение, она зашифрует его с применением открытого ключа. Зашифрованное сообщение можно расшифровать только с закрытым ключом.
Дальше изучение криптографии.

VII. Линейное программирование.
Линейное программирование используется для максимизации некоторой характеристики при заданных ограничениях.
Все алгоритмы, работающие с графами, могут быть реализованы средствами линейного программирования.
Линейное программирование - намного более общая область, а задачи с графами составляют ее подмножество.
В линейном программировании используются симплекс-метод.
